# -*- coding: utf-8 -*-
"""Association_Rules_Learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ywA3cerSro2PRCZSPJg2cttBgmzIRWpW

# **ASSOCIATION RULE LEARNING (BİRLİKTELİK KURALI ÖĞRENİMİ)**

Our aim is to suggest products to users during the purchasing process by applying association analysis to the online retail II dataset. 

1. Importing Data & Data Preprocessing
2. Preparing ARL Data Structure (Invoice-Product Matrix)
3. Preparation of Association Rules
4. Suggesting a Product to Users at the Basket Stage
(Our aim is to suggest products to users in the product purchasing process by applying association analysis to the online retail II dataset.)

**1. Importing Data & Data Preprocessing**
"""

# Import Libraries

# !pip install mlxtend
import pandas as pd
pd.set_option('display.max_columns', None)
pd.set_option('display.width', 500)
pd.set_option('display.expand_frame_repr', False)

# Libraries for Association Rules Learning & Apriori 
from mlxtend.frequent_patterns import apriori, association_rules

"""**Data Import**"""

# Import Data:

df_ = pd.read_excel('online_retail_II.xlsx', sheet_name='Year 2010-2011')

df = df_.copy()
df.info()
df.head()

"""**Data Preprocessing**"""

# Removing the null (missing) value 

df.isna().sum()
df.dropna(inplace=True)
#df.shape

# # Let's remove the returned product transactions (Invoice Id contains value "C")


df_Invoice = pd.DataFrame({"Invoice":[row for row in df["Invoice"].values if "C"  not in str(row)]})
df_Invoice.head()
df_Invoice = df_Invoice.drop_duplicates("Invoice")

# Veri setimizle merge edelim :
df = df.merge(df_Invoice, on = "Invoice")

"""
# 2.Yöntem : 
df = df[~df["Invoice"].str.contains("C", na=False)]
"""

# Removing  Outliers with Interquartile Range Method


# Price:

Q1 = df["Price"].quantile(0.01)
Q3 = df["Price"].quantile(0.99)
IQR = Q3- Q1

low_limit = Q1 - 1.5 * IQR
up_limit = Q3 + 1.5 * IQR


df.loc[(df["Price"] < low_limit), "Price"] = low_limit
df.loc[(df["Price"] > up_limit ), "Price"] = up_limit

 # Quantity:
 
Q1 = df["Quantity"].quantile(0.01)
Q3 = df["Quantity"].quantile(0.99)
IQR = Q3- Q1

low_limit = Q1 - 1.5 * IQR
up_limit = Q3 + 1.5 * IQR

df.loc[(df["Quantity"] < low_limit), "Quantity"] = low_limit
df.loc[(df["Quantity"] > up_limit ), "Quantity"] = up_limit

# Delete values less than or equal to 0 in the variables Quantity and Price

df = df[df["Quantity"] > 0]
df = df[df["Price"] > 0]

# Unique Number of Products (with Description)

df.Description.nunique()

# Unique Number of Products (with StockCode)

df.StockCode.nunique()

# The quantities calculated on these 2 variables should be equal, because each stock code represents a product.
df_product = df[["Description","StockCode"]].drop_duplicates()
df_product = df_product.groupby(["Description"]).agg({"StockCode":"count"}).reset_index()

df_product.rename(columns={'StockCode':'StockCode_Count'},inplace=True)


product_counts = df_product.sort_values("StockCode_Count", ascending=False)
product_counts_eliminate = product_counts[product_counts["StockCode_Count"]>1]

# Data Cleaning
df = df[~df["Description"].isin(product_counts_eliminate["Description"])]

# Now each stock code represents a single product

print(df.StockCode.nunique())
print(df.Description.nunique())

# The post statement in the stock code shows the postage cost, let's delete it as it is not a product

df = df[~df["StockCode"].str.contains("POST", na=False)]

# Let's work on shopping transactions with Germany as an example:  

df_germany = df[df["Country"] == "Germany"]

"""**Preparing Data Structure (Invoice-Product Matrix)**"""

# Let's work on shopping transactions with France as an example:

df_germany = df[df["Country"] == "Germany"]

#  

# Description   NINE DRAWER OFFICE TIDY   SET 2 TEA TOWELS I LOVE LONDON    SPACEBOY BABY GIFT SET
# Invoice
# 536370                              0                                 1                       0
# 536852                              1                                 0                       1
# 536974                              0                                 0                       0
# 537065                              1                                 0                       0
# 537463                              0                                 0                       1

gr_inv_pro_df = create_invoice_product_df(df_germany, id=True)
gr_inv_pro_df.head(3)

# Creating Invoice- Product Matrix

def create_invoice_product_df(dataframe, id=False):
    if id:
        return dataframe.groupby(["Invoice","StockCode"]).agg({"Quantity":"sum"}).unstack().fillna(0).\
                                            applymap(lambda x: 1 if x>0 else 0)
    else:
        return dataframe.groupby(["Invoice","Description"]).agg({"Quantity":"sum"}).unstack().fillna(0).\
                                            applymap(lambda x: 1 if x>0 else 0)


gr_inv_pro_df = create_invoice_product_df(df_germany, id=True)
gr_inv_pro_df.columns = gr_inv_pro_df.columns.droplevel(0)

gr_inv_pro_df.head()

# We can perform the product matrix via Invoice Id or product name 

def create_invoice_product_df(dataframe, id=False):
    if id:
        return dataframe.groupby(["Invoice","StockCode"]).agg({"Quantity":"sum"}).unstack().fillna(0).\
                                            applymap(lambda x: 1 if x>0 else 0)
    else:
        return dataframe.groupby(["Invoice","Description"]).agg({"Quantity":"sum"}).unstack().fillna(0).\
                                            applymap(lambda x: 1 if x>0 else 0)

# Description'ı kullanarak yukarıdaki gibi pivot table'ı (invoice prduct matris) oluşturalım:

fr_inv_pro_df = create_invoice_product_df(df_fr)
fr_inv_pro_df.head()

# Stockode ile de invoice product matris oluşturalım:
fr_inv_pro_df = create_invoice_product_df(df_fr, id=True)
fr_inv_pro_df.head(10)

fr_inv_pro_df.columns = fr_inv_pro_df.columns.droplevel(0)

fr_inv_pro_df.head(4)

# StockCode hangi ürüne ait bulmak için fonksiyon tanımlayalım:

def check_id(dataframe, stockcode):
    # product_name = dataframe,[dataframe,["StockCode"] == stockcode]["Description"]
    # df_fr[df_fr["StockCode"] == 10002]["Description"].value_counts().index.to_list()
    product_name = dataframe[dataframe["StockCode"] == stockcode][["Description"]].values[0].tolist()
    # product_name = dataframe[dataframe["StockCode"] == stockcode]["Description"].drop_duplicates().values
    print(product_name)

check_id(df_fr, 10002)
check_id(df_fr, 10120)

"""**2. Preparing ARL Data Structure (Invoice-Product Matrix)**"""

#  calculate the support values for every possible configuration of items (thereshold of support has been chosen 0.01 (1%)

frequent_itemsets = apriori(fr_inv_pro_df, min_support=0.01, use_colnames=True)
frequent_itemsets.sort_values("support", ascending=False).head(100)

"""support                               itemsets
442   0.652928                     ((Quantity, POST))
325   0.160521                    ((Quantity, 23084))
93    0.154013                    ((Quantity, 21731))
203   0.145336                    ((Quantity, 22554))
205   0.143167                    ((Quantity, 22556))
6700  0.058568  ((Quantity, 22554), (Quantity, 22556), (Quanti...

**3.Preparation of Association Rules**
"""

# Finding frequent patterns, associations
#  Note: An association rule has two parts: an antecedent (if) and a consequent (then). An antecedent is an item found within the data. A consequent is an item found in combination with the antecedent
rules = association_rules(frequent_itemsets, metric="support", min_threshold=0.01)
rules.sort_values("support", ascending=False).head(5)

# antecedents: Önceki ürün
# antecedent support: Tek başına X olasılığı
# consequents: Sonraki ürün
# consequent support: Tek başına Y olasılığı
# support: İkisinin birlikte görülme olasılığı
# confidence: X alındığında Y alınma olasılığı.
# lift: X alındığında Y alınma olasılığı .. kat artar.
# conviction: Y olmadan X'in beklenen frekansı

rules.sort_values("lift", ascending=False).head(500)

# Özetle; X alındığında Y alınma olasılığına göre (confidence) sıralayıp ürün teklifi yapabiliriz ya da
# lift üzerinden satış olasığı kaç kat artıyorsa buna göre teklif yapabiliriz.
# support, lift ve confidence 'ın birlikte kullanıldığı hibrit bir filtreleme ile de ürün seti önerilebilir.

"""**Suggesting a Product to Users at the Basket Stage **"""

# Örnek:
# Kullanıcı örnek ürün id: 22492

product_id = 22492
check_id(df, product_id)

# Lift'e bakarak ürün önereceğimizi düşünelim, kurallarımızı lift azalan şekilde sıralayalım:
sorted_rules = rules.sort_values("lift", ascending=False)
sorted_rules.head()

# Önerilecek ürünler için bir liste oluşturalım:
# İlk ürün setlerinde (antecedents) gezip, 22492 id li ürün var mı kontrol edeceğiz.
# Bu kolonda product id bulursak, bulduğumuz yerin indexi ne onu bulacağız.
# Bulduğumuz indexi consequentte bulup ilgili ürünü teklif edeceğiz:

# Hem index hem de objede gezeceğimiz için enumarate kullanalım:
# enumerate df'in kaçıncı satırında yani indexinde ilgili elemanı yakaladığımızı verir, yan, 25.index ise consequents'de aynı indexi bulur, içindeki ürünleri alır

recommendation_list = []

for idx, product in enumerate(sorted_rules["antecedents"]):
    # antecendent tuple olduğu için listeye çevirelim ve liste içinde arayalım:
    for j in list(product):
        if j == product_id:
            # bu yakaladığımız integer değerin indexi ne ise (idx) consequentte onu arayacağız, bulduğumuz satırlar için ilk ürünü [0]  önerelim 
            recommendation_list.append(list(sorted_rules.iloc[idx]["consequents"])[0])

recommendation_list

#ilk 5 ürünü getirelim:

list5 = recommendation_list[0:5]

list5.pop(0)

list5.pop(1)

list5

# Fonksiyon sonucunu input olarak kulanmak için

def check_id(dataframe, stockcode):
    # product_name = dataframe,[dataframe,["StockCode"] == stockcode]["Description"]
    # df_fr[df_fr["StockCode"] == 10002]["Description"].value_counts().index.to_list()
    product_name = dataframe[dataframe["StockCode"] == stockcode][["Description"]].values[0].tolist()
    # product_name = dataframe[dataframe["StockCode"] == stockcode]["Description"].drop_duplicates().values
    return stockcode, product_name

# bu 5 ürünün ne olduğunu bulalım:

for elem in list5:
  print(check_id(df_fr,elem))